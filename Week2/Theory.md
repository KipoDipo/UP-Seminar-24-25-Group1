# Булеви изрази

```cpp
int x = 5;
int y = 3;
cout << x == y; // 0
cout << x >= y; // 1
cout << x != y; // 1
```

```cpp
int x = 5;
int y = 4;
int z = x;

cout << (x == z) && (y < x) && (y != z);
cout << !(z == y) || (x != y) || (x <= z);
```

```cpp
int x = 1, y = 2, z = 3;

cout << x > y || y > x && z > x;
```

**Приоритет**: ***&&*** е с *по-висок* приоритет от ***||***

```
x > y || y > x && z > x

е същото като

(x > y) || (y > x && z > x)

докато може би сме искали

(x > y || y > x) && (z > x)
```

## Закони на Де Морган

На какво е еквивалентен изразът ``!(X && Y)``? 

Честа грешка е отговорът ``!X && !Y``

``!(X && Y)`` е еквивалентно на ``!X || !Y``\
``!(X || Y)`` е еквивалентно на ``!X && !Y``

# Блок и видимост на данни
Код, заграден с {}, се нарича блок. Във всеки блок идентираме с таб веднъж след отварящата скоба.
```cpp
{
    cout << "Hello, world!";
}
```

```cpp
{
    cout << "Hello,";

    {
        cout << " world!";
    }
}
```

Променливите направени в един блок, са видими само и единствено за този блок, както и вградените в него блокове.

```cpp
{
    int a = 10;
    cout << a;
    {
        int b = 20;
        cout << "\t" << b;
    }

    cout << "\t" << a + b; // ERROR: b не съществува в този блок
}
```
Ако искаме да запазим стойността на променлива, която ще се получи в блок, извън този блок, можем да приложим следната техника.


```cpp
{
    int a = 10;
    int b;
    cout << a;
    {
        b = 20;
        cout << "\t" << b;
    }

    cout << "\t" << a + b; // OK
}
```

Тези променливи се наричат *локални*, защото са локални за някакъв блок от код. Освен тях съществуват и *глобални* - те се намират извън всяка функция, включително главната (main).

```cpp
#include <iostream>
using namespace std;

int windowsVersion = 11; // global variable

int main()
{
    cout << windowsVersion; 
}
```

*Забележка:* Избягвайте използването на глобални променливи, ако е възможно, тъй като са считани за недобра практика.

# if, else if, else
Контролирането на това кога даден фрагмент от кода да се изпълни и кога не е съществена част от писането на какъвто и да е код. Първият начин за да постигнем този контрол, който ще разгледаме, е конструкцията ``if``.

```cpp
if (<булев_израз>)
{
    // code
}
```

Ако стойността на ``<булев_израз>`` е оценена до true, кодът в блока свързан към ``if`` ще се изпълни. Ако ли не - ще се пропусне.

```cpp
bool hasDrunk = false;
bool isOver18 = true;
bool hasLicense = true;

if (!hasDrunk && isOver18 && hasLicense)
{
    cout << "You can drive!";
}
```

Ако искаме да изпълним код, в случай че условието е оценено до false, използваме ``else``.

```cpp
bool hasDrunk = false;
bool isOver18 = true;
bool hasLicense = true;

if (!hasDrunk && isOver18 && hasLicense)
{
    cout << "You can drive!";
}
else
{
    cout << "You CAN'T drive!";
}
```

Ако искаме да направим множество проверки, имаме няколко варианта. Единият е с няколко if-a.

```cpp
int input;
cin >> input;

if (input % 2 == 0)
{
    cout << input << " is divisible by 2\n";
}
if (input % 10 == 0)
{
    cout << input << " is divisible by 10\n";
}
```

Какво очакваме при входовете: ``1, 2, 6, 10, 12, 20``?

При вход 2, 6 и 12 ще получим на изхода:
```
x is divisible by 2
```
където х е съответното число.

При вход 10 и 20 ще получим на изхода:
```
x is divisible by 2
x is divisible by 10
```
\
\
Вариант в който **точно 1** блок ще се изпълни е с конструкцията else if.

```cpp
int input;
cin >> input;

if (input % 2 == 0)
{
    cout << input << " is divisible by 2\n";
}
else if (input % 10 == 0)
{
    cout << input << " is divisible by 10\n";
}
```

Какво очакваме при входовете: ``1, 2, 6, 10, 12, 20``?

При вход 2, 6 и 12 ще получим на изхода:
```
x is divisible by 2
```
където х е съответното число.

При вход 10 и 20 ще получим на изхода:
```
x is divisible by 2
```
\
\
**Важно!** При последователни if проверки, всяка една от тях ще бъде изпълнена. При последователни else if проверки, след първата проверка, която е вярна, следните **не** се проверяват.  


# Тернарен оператор ?:
Конструкцията ``?:`` се нарича тернарен оператор и той цели да опрости някои if/else конструкции.

```
<булев_израз> ? <израз_при_истина> : <израз_при_лъжа>
```

Пример:
```cpp
bool isFromAmerica;
cin >> isFromAmerica;

int drinkingAge = isFromAmerica ? 21 : 18;

// еквивалентно на:

int drinkingAge;
if (isFromAmerica)
{
    drinkingAge = 21;
}
else
{
    drinkingAge = 18;
}
``` 

# switch
``switch`` позволява тестването на дадена <u>числова</u> променлива или израз за равенство измежду списък от стойностти. Всяка стойност за проверка се нарича случай (case). За случай, който да се изпълни, когато нито една от стойностите не съвпада с елемент от списъка, използваме ``default`` (не е задължително).

```cpp
switch(<израз|стойност>)
{
	case <стойност_за_проверка>: 
    <операции_за_изпълнение>
    break;
	...
	case <стойност_за_проверка>:
    <операции_за_изпълнение> 
    break;

	default:
    <операции_за_изпълнение> 
    break;
}

```
Забелязваме, че в края на всеки случай има break. Той не е задължителен, но има много важна роля. Когато попаднем в някой случай, кодът от него, до края на блокът за switch ще се изпълни, освен ако не е срещнат break;

```cpp
switch(input)
{
    case 1:
    cout << "one";
    
    case 2:
    cout << "two";

    case 3:
    cout << "three";
}
```
При вход ``1``, на изхода ще имаме: ``onetwothree``

За това в почти всички случаи ще искаме да има break, освен ако наистина знаем че искаме кодът да продължи надолу. Това пропускане на break се нарича fall-through.

```cpp
switch(input)
{
    case 1:
    cout << "one";
    break;
    
    case 2:
    cout << "two";
    break;

    case 3:
    cout << "three";
    break;
}
```
При вход ``1``, на изхода ще имаме: ``one``


Пример, когато fall-through е приложимо:
```cpp
switch(month)
{
    case 3:
    case 4:
    case 5:
    cout << "Spring";
    break;

    case 6:
    case 7:
    case 8:
    cout << "Summer";
    break;

    case 9:
    case 10:
    case 11:
    cout << "Autumn";
    break;

    case 12:
    case 1:
    case 2:
    cout << "Winter"
    break;

    default:
    cout << "ERROR";
    break;
}