# Рекурсия

Рекурсията представлява викане на функция в тялото на същата функция. Напр. долният код е рекурсия:

```cpp
void foo()
{
    cout << "Message!" << endl

    foo(); 
}
```

```
Message!
Message!
Message!
Message!
Message!
Message!
Message!
...
```

Рекурсията има 2 задължителни части: Базов случай (base case) и Рекурсивно извикване.
- **Базов случай**: Условие при което рекурсията спира. Без базовия случай рекурсията ще продължи безкрайно, както в горния пример.
- **Рекурсивно извикване**: Моментът, в който функцията извиква сама себе си с променени параметри, с цел доближаване до базовия случай.

Най-често се разглежда задачата за намиране на факториел на число.  

Знаем, че:  
`n! = n * (n - 1) * (n - 2) * ... * 1`

Също така:  
`n! = n * (n - 1)!`

Базовият ни случай ще бъде:  
`0! = 1`  
т.к. `0!` не е равно на `0 * (0 - 1)!` а на `1` по дефиниция

```cpp
int factorial(int n)
{
    if (n == 0) // базов случай
        return 1;

    return n * factorial(n - 1); // рекурсивно извикване
}
```

Например за `n = 3` имаме:
- factorial(3) връща 3 * factorial(2)
- factorial(2) връща 2 * factorial(1)
- factorial(1) връща 1 * factorial(0)
- factorial(0) връща 1 (базов случай)

След това резултатите се изчисляват наобратно:
- factorial(1) = 1 * 1 = 1
- factorial(2) = 2 * 1 = 2
- factorial(3) = 3 * 2 = 6

# Stack Overflow
Освен име на сайт, с който всички сме запознати, `Stack Overflow` преди всичко е грешка която получаваме, когато не внимаваме с рекурсията.

Рекурсията, въпреки че често представлява доста елегантно решение на даден проблем, идва с цена - памет. Всяко рекурсивно повикване заделя памет в стека, и ако забравим да зададем правилен базов случай, рекурсията става безкрайна, а с това и паметта която се заделя в стека. Както знаем, лимита на стека не е особено голям, за това и лесно се достига, и при програма като в примера от началото  
```cpp
void foo()
{
    cout << "Message!" << endl

    foo(); 
}
```
рано или късно ще крашнем приложението с грешка `Stack Overflow`.

# Линейни и нелинейни рекурсии
Рекурсивно намиране на факториел на число е типичен пример за *линейна* рекурсия. Линейна е в смисъл, че паметта, която заема нараства линейно - 1 повикване на функцията води до 1 ново повикване на функцията. 

Нека разгледаме задача за намиране на числата на Фибоначи.

По дефиниция, формулата е както следва:  
`F(n) = F(n - 1) + F(n - 2)`, т.е. всяко число е сумата от предните 2
Но за да започнем адекватно, тя не се прилага за първите 2 числа - 0 и 1  
`F(0) = 0`  
`F(1) = 1`  
Това са нашите 2 базови случая (нищо не пречи да имаме няколко)

Съответно функцията ще има следния вид:
```cpp
int fibonacci(int n)
{
    if (n == 0)
        return 0;

    if (n == 1)
        return 1;

    return fibonacci(n - 1) * fibonacci(n - 2);
}
```

Виждаме, че всяко изпълнение на функцията, води до 2 нови извиквания на същата тази функция. Това прави тази рекурсивна функция *нелинейна* (в този случай *бинарна*, поради 2те повиквания).