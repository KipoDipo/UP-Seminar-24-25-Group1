# Масив (array)
Масивите са първият (и единственият за този курс) и най-важният тип *структури от данни*, който ще разгледаме. Те са основна част от езика, без които много задачи са непосилни.

Масивите представляват *наредени еднотипни* елементи. Тяхната бройка се определя от *размера* на масива. Когато създаваме масив, трябва да определим неговия размер, като го напишем в квадратни скоби `[]` след името на масива.

Пример:
```cpp
int arr[30];
```
*Забележка!* Когато създаваме масиви, техният размер трябва да бъде ***ясен по време на компилация***. Това означава, че не можем да въведем размера на масива от конзолата.

```cpp
int arr[30]; // OK
```
```cpp
const int SIZE_OF_ARRAY = 30;
int arr[SIZE_OF_ARRAY]; // OK*
```
<br/>
<br/>

```cpp
int size = 30;
int arr[size]; // NOT OK
```
```cpp
int size;
cin >> size;

const int SIZE_OF_ARRAY = size;
int arr[SIZE_OF_ARRAY]; // NOT OK
```

## Памет
Когато създаваме масив, в паметта трябва да се заделя точно толкова място, колкото е нужно за да се побере масивът. Тоест, когато направим масив с размер 10, се заделят 10 "клетки" памет. Всяка една от тези клетки играе ролята на променлива.

Масив, тип int, от 3 елемента би изглеждал по следния начин в паметта:
```
[0] [42] [8888]
```
Всяка една от тези клетки съдържа по един int в тях.

Стековите масиви, както и типичните променливи, се намират в т.нар. стекова памет (stack). Освен нея съществуват още две (статична и динамична), но за тях ще говорим по-късно.

## Индексиране
За да достъпим някой елемент от масива, използваме отново квадратните скоби, като в тях поставяме индекса на искания елемент.
```cpp
cout << arr[0];  // [0] е първият елемент на масива
cout << arr[10]; // кой елемент е [10]?

for (int i = 0; i < 10; i++)
{
    cout << arr[i] << '\n';
}
```

## Инициализиране
Видяхме как се декларира масив по-горе. Ако искаме този масив да има някакви данни в него, трябва да го инициализираме. За това има няколко подхода.

1)  ```cpp
    int arr[5] = {1, 2, 3, 4, 5};
    ```
2)  ```cpp
    int arr[] = {1, 2, 3};
    ```
3)  ```cpp
    int arr[5] = {1}; // останалите елементи стават 0
    ```
4)  ```cpp
    int arr[5] = {}; // всички елементи ще са 0
    ```
5)  ```cpp
    int arr[5];
    arr[0] = 1;
    arr[1] = 4;
    arr[2] = 62;
    arr[3] = 0;
    arr[4] = 9912;
    ```
6)  ```cpp
    int arr[5];
    for (int i = 0; i < 5; i++)
        cin >> arr[i];
    ```

*Важно!* При масивите, името на променливата не представлява целия масив, а само неговото начало. Следователно не можем да подадем масива на cout и да очакваме че това ще го принтира в някакъв формат. Когато подадем масив на потока за извеждане, на екрана ще получим адреса на първия му елемент. За адреси ще говорим по-късно. 

# Символен низ (string)
Символния низ е масив съставен от символен тип. Най-често това е char. 
```cpp
char str[100];
```
Те са по-особени в това, че накрая на всеки низ трябва да има поставен терминиращ символ (ASCII код 0) `\0`, който символизира края на низа.

```cpp
char str[6] = {'H', 'e', 'l', 'l', 'o', '\0'}
```

За низовете, също така, са дефинирани и операторите `<<` и `>>` при съответните потоци cout и cin.

```cpp
char str[6] = {'H', 'e', 'l', 'l', 'o', '\0'}

cout << str;
```
```
Hello
```
За да избегнем това писане на `'\0'`, можем да напишем низа, който искаме да запазим, в двойни кавички `""`, които го поставят автоматично в края.

```cpp
char str[6] = "Hello"; // 5 символа + '\0'
cout << str;
```
Позволен е и следният вариант:
```cpp
char str[] = "Hello, world!";
cout << str;
```

Когато искаме да въвеждаме някакъв низ, трябва да сме сигурни, че ще заделим достатъчно буферно пространство, за да не прескочим границите на масива.

```cpp
char buffer[1024];

cin >> buffer;
```
*В стандартната библиотека на С++ съществува и готовата структура `std::string`, но в рамките на курса по УП, не се позволява използването ѝ.*

# sizeof
sizeof е оператор, който ни показва колко памет(в байтове) заема дадена променлива от съответен тип. Може да се използва по 2 начина:
```cpp
int a = 10;

cout << sizeof(a);
//или
cout << sizeof a;
```

Освен това може да се провери директно за някой тип, в който случай можем да използваме само:
```cpp
cout << sizeof(int);
```

```cpp
cout << "bool:\t" << sizeof(bool) << " bytes" << endl;
cout << "char:\t" << sizeof(char) << " bytes" << endl;
cout << "short:\t" << sizeof(short) << " bytes" << endl;
cout << "int:\t" << sizeof(int) << " bytes" << endl;
cout << "long:\t" << sizeof(long) << " bytes" << endl;
cout << "float:\t" << sizeof(float) << " bytes" << endl;
cout << "double:\t" << sizeof(double) << " bytes" << endl;
cout << "long double:\t" << sizeof(long double) << " bytes" << endl;
```

```cpp
bool:    		1 bytes
char:    		1 bytes
short:    		2 bytes
int:    		4 bytes
long:    		8 bytes
float:    		4 bytes
double:         8 bytes
long double:    16 bytes
```

Ако използваме sizeof върху масив, тогава ще получим неговия размер (отново, в байтове)

```cpp
double arr[100];

cout << sizeof(arr);
```
```
800
```