# Видове памети
Езикът С++ ни дава възможност да боравим с 3 вида памети.
- Стекова (stack)
- Динамична (heap)
- Статична (static)

До сега сме се сблъсквали само със стековата памет. 

## Стекова памет
1) Тя е най-бързата
2) Тя е мястото където живеят всички променливи
3) Подредена е в RAM паметта последователно, като има определен лимит (типично е `1Mb`)
4) Тя освобождава заетата памет, когато променлива (или масив) излезе извън обсег (scope)
5) Размерът на един масив задължително трябва да се знае преди компилация

## Динамична памет
1) Тя е по-бавна
2) Не можем директно да създаваме променливи на нея
    - Можем само да заделяме памет, към която да сочим с указател 
3) Няма подредба, всяка заделена динамична памет се намира на случайно място в RAM паметта (следователно лимита и е колкото RAM имаме)
4) Не освобождава заетата памет автоматично - трябва ръчно да го направим
5) Размерът на един масив може да се зададе по време на изпълнение (runtime)

## Статична памет
За нея ще говорим по-нататък :)

# Защо да ползваме динамична памет
От изброените неща, не изглежда все едно да е най-полезното нещо. До сега сме се справяли и без нея. В реалния свят, когато можем да избегнем динамична памет, го правим. Но това често не е много скалируемо.  
Както казахме, стековата памет има доста малък лимит, а ако приложението ни трябва да се занимава с обработка на няколко мегабайта (или дори гигабайта), нямаме друг избор освен да се обърнем към динамичната памет.

# Инициализация
Както казахме по-рано, не можем да създаваме променливи на динамичната памет. Можем само да заделим някаква памет в този участък.  

Това, което *можем*, обаче, е да заделим памет в случаен участък от RAM паметта, и да вземем адреса на този участък.

```cpp
<type>* <name> = new <type>;

<type>* <name> = new <type>(<value>);

<type>* <name> = new <type>{<value>};
```

Пример:
```cpp
int* dynamic = new int(10);
```

Сега в динамичната памет, някъде, има стойността 10, а ние имаме указател на стека, който сочи към тази памет.

Какъв е смисълът от това? Тъй като динамичната памет не се освобождава автоматично, вече можем да създадем стойност в scope, и да я запазим.

Проблем със стекова памет:
```cpp
int* ptr = nullptr;

if (ptr == nullptr)
{
    int val = 10;
    ptr = &val;
}

cout << *ptr; // Undefined behaviour, 'val' is out of scope and its memory was freed
```

Решение с динамична памет:
```cpp
int* ptr = nullptr;

if (ptr == nullptr)
{
    ptr = new int(10);
}

cout << *ptr; // OK, will print '10'
```

Добре де, какъв пък е смисълът от това, можеше просто да си направим нормална променлива и да ѝ копираме стойността в scope-a и нямаше да имаме проблем. Това е *вярно* - за това динамичната памет типично *не* се ползва, когато говорим за нормални променливи.

# Динамични масиви
От друга страна, динамичната памет е страшно полезна при създаването на масиви с какъв да е размер.

```cpp
<type>* <name> = new <type>[<length>];

<type>* <name> = new <type>[<length>] {val1, val2};
```

Например:
```cpp
int* arr = new int[10];
```

Или
```cpp
int n = 1024;
int* arr = new int[n]
```

Или
```cpp
int n;
cin >> n;

int* arr = new int[n];
```

От тук използването на масива си е както винаги е било, просто сега самия масив живее в динамичната памет, вместо в стековата.

# Освобождаване на паметта
Всичко хубаво си има край. Така и нашата динамична памет, въпреки че е много удобна, трябва да бъде освободена, и то от нас.

Освобождаването на динамични променливи става по следния начин:
```cpp
delete <name>;
```

Освобождаването на динамични масиви става по следния начин:
```cpp
delete[] <name>;
```

---

**Важно 1:**  
***По какъвто начин сме заделили динамичната памет, трябва да я освободим по същия начин!!!***  

Това означава, че ако сме заделили памет с ``new <name>``, я изтриваме с ``delete name``.  
Ако сме я заделили с ``new <name>[<length>]``, я изтриваме с ``delete[] <name>``.  
Тези два ``delete`` оператора *не трябва да се бъркат*.

---

**Важно 2:**  
***Освобождаването на динамичната памет, НЕ означава, че стойността ѝ става `nullptr`***  
  
Тоест след като сме освободили паметта срещу указателя, не трябва да четем от него докато не сложим друга конкретна стойност (вкл. `nullptr`)

---

**Важно 3:**
***Освобождаваме само памет, която е заделена динамично***  

Ползваме `delete` само за памет, която е заделена с `new`, и *никога* за стекова.

---

Пример:
```cpp
int* ptr = nullptr;

if (ptr == nullptr)
{
    ptr = new int(10);
}

cout << *ptr;

delete ptr;
```
---
Нека разгледаме следната програма:
```cpp
int *ptr = new int(10);

if (*ptr % 2 == 0)
{
    ptr = new int(100);
}

cout << *ptr;
delete ptr;
```

Тази програма ще си работи добре - имаме динамична стойност `10` към която сочи `ptr`, а после `ptr` ще се пренасочи към `100`. Това `100`, обаче, се намира на съвсем различно място в паметта, а ние изгубихме адреса на старата стойност `10`. Това се нарича *теч на памет* (или *memory leak*). 

За да избегнем това, преди да насочим указателя към ново място, трябва да изтрием старата памет.
```cpp
int *ptr = new int(10);

if (*ptr % 2 == 0)
{
    delete ptr; // <--
    ptr = new int(100);
}

cout << *ptr;
delete ptr;
```

Друг лесен начин да причиним memory leak е ако просто заделим динамична памет, без да ѝ взимаме адреса:
```cpp
new int[100];
```

Като rule of thumb - за всяко `new`, трябва да има `delete`.

# Функции
Сега вече можем да напишем функция, която да ни връща масив.

Ще разгледаме проста задача за създаване на нов масив, който НЕ съдържа елементите К от подаден масив:
```cpp
int* removedK(const int arr[], int size, int k, int& resultLength)
{
    resultLength = 0;
    for (int i = 0; i < size; i++)
    {
        if (arr[i] != k)
            resultLength++;
    }
    // we found how many elements the new array will have

    int* result = new int[resultLength];
    for (int i = 0, j = 0; i < size; i++) 
    {
        /*
            i - counter for input arr
            j - counter for result arr
        */
        if (arr[i] != k)
        {
            result[j] = arr[i];
            j++;
        }
    }

    return result;
}
```
```cpp
int main()
{
    int arr[5] {1,1,2,1,3};
    int length = 0;
    int* remove1 = removeK(arr, 5, 1, length);

    for (int i = 0; i < length; i++)
    {
        cout << remove1[i] << " ";
    }

    delete[] remove1; // don't forget to free the memory
                      // `new` wasn't obvious, but it was called
}
```
---
```
2 3
```

# For fun

Какво ще стане при следващата програма?
```cpp
int main()
{
    while (true)
    {
        int arr[16] {};
    }
}
```
А при следващата?
```cpp
int main()
{
    while (true)
    {
        int* ptr = new int[16]; 
    }
}
```