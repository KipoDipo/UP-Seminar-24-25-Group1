# Масиви vs Типични променливи

## Копиране
При типичните променливи, копирането е тривиална операция.
```cpp
int a = 5;
int b = a; // b = 5
```
При масивите обаче, тривиално копиране не е възможно.
```cpp
int arr[5] = {1,2,3,4,5};
int cpy[5] = arr; // ERROR
```
Това се дължи на редица причини, но една от по-важните е, че С++ *не* знае колко е дължината на който и да е масив - това не е информация, която се запазва някъде, следователно тази функционалност липсва.

За да копираме стойностите на един масив в друг, нямаме друг избор освен да обходим оригиналния и да зададем съответните стойности в копирания.

```cpp
int arr[5] = {1,2,3,4,5};
int cpy[5];

for (int i = 0; i < 5; i++)
{
    cpy[i] = arr[i];
}
```

## const
Както при нормалните променливи, масивите могат да бъдат и константни, т.е. веднъж зададени техните стойности *при инициализация*, те не могат да бъдат променени.
```cpp
const float PI = 3.141592f;

const unsigned DISPLAY_PROPERTIES[] = {1920, 1080, 144, 8};

cout << "Value of pi: " << PI << endl << endl;

cout << "Width: " << DISPLAY_PROPERTIES[0] << endl;
cout << "Height: " << DISPLAY_PROPERTIES[1] << endl;
cout << "Refresh rate: " << DISPLAY_PROPERTIES[2] << endl;
cout << "Bit depth: " << DISPLAY_PROPERTIES[3]; 

PI = 3.f; // ERROR
DISPLAY_PROPERTIES[2] = 60; // ERROR
```

Константните променливи могат да имат за стойност и неконстантни променливи. 
```cpp
int value = 10;
const int CONST_VALUE = value;

value = 15;

/*
    value === 15
    CONST_VALUE === 10
*/

```

## Параметри на функции

### Подаване на масив като параметър
Както вече знаем, когато подаваме променливи като параметри на някоя функция, в контекста на функцията се работи с копие на променливата.

```cpp
int doubleNumber(int number)
{
    number *= 2;
    return number;
}

int main()
{
    int x = 2;
    int y = doubleNumber(x);
    cout << x << " " << y;
}
```
```
2 4
```
*виждаме че `х` не се променя, въпреки че го подадохме като параметър, т.е. се създава копие - на практика `int number = x;`* 

Типичната променлива е т.нар. *стойностен типо (value type)*.\
Масивът от друга страна е т.нар. *реферeнтен тип (reference type)*.

По-рано казахме, че масивите не могат да се копират тривиално. Когато масиви се подават като параметри на функции, те *не* се копират и следователно се работи със същия масив (същата памет).

```cpp
void foo(int array[5])
{
    array[0] = 999;
}

int main()
{
    int arr[5] = {1,2,3,4,5};
    for (int i = 0; i < 5; i++)
    {
        cout << arr[i] << ' ';
    }
    cout << endl;
    
    foo(arr);

    for (int i = 0; i < 5; i++)
    {
        cout << arr[i] << ' ';
    }
}
```

```
1 2 3 4 5
999 2 3 4 5
```

Трябва да сме много внимателни с това поведение, защото в много случаи *не* искаме да модифицираме входните данни.

### Предотвратяване на промени по масива

За да подсигурим, че функцията *няма* да промени стойностите на оригиналния масив, можем да направим параметъра константен.

```cpp
void foo(const int array[5])
{
    array[0] = 999; // ERROR
}
```

### Правилно подаване на масиви като параметър

С++ е доста доверчив и вярва на програмиста, че размерът на подадения масив и този на параметъра съвпадат. Това позволява компилирането на следния *грешен* код.

```cpp
void foo(const int arr[10])
{
    for (int i = 0; i < 10; i++)
    {
        std::cout << arr[i] << " ";
    }
}

int main()
{
    int arr[5] {1,2,3,4,5};
    foo(arr);
}
```
Примерен изход:
```
1 2 3 4 5 0 85 0 1752444718 1882092393 
```

Това се случва по причини, за които ще говорим по-късно, но на този етап, С++ не вижда разлика на размерите на масив като параметър, т.е. дали ще напишем ``const int arr[5]``, ``const int arr[10]``, ``const int arr[999]``, няма значение. Съществува по-разпространения начин за записване на масив като параметър:
```cpp
const int arr[]
```

```cpp
void foo(const int arr[])
```

Размерът на този масив ще подаваме като допълнителен параметър, тип ``unsigned`` (или ``size_t``)

```cpp
void foo(const int arr[], unsigned size)
{
    for (unsigned i = 0; i < size; i++)
    {
        std::cout << arr[i] << " ";
    }
}

int main()
{
    int arr[5] {1,2,3,4,5};
    foo(arr, 5);
}
```

Сега вече прехвърляме отговорността към програмиста да следи и да знае колко е размерът на масивите, които подава.

Съответно ако искаме да подадем масив, който *искаме* да модифицираме, не пишем ``const``

```cpp
void setArray(int arr[], unsigned size, int value)
{
    for (int i = 0; i < size; i++)
    {
        arr[i] = value;
    }
}

void printArray(const int arr[], unsigned size)
{
    for (int i = 0; i < size; i++)
    {
        cout << arr[i] << " ";
    }
}

int main()
{
    int arr[5];
    setArray(arr, 5, 1);
    printArrat(arr, 5);
}
```