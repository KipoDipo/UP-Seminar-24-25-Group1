# Указатели
Указателите (пойнтърите) са специален тип, който съхранява адреси.

## Адреси
Както вече знаем, всяка променлива, която създаваме, се намира на някакъв адрес. За да вземем адреса на някоя променлива, слагаме оператор `&` пред името ѝ.
```cpp
int a = 10;

cout << &a;
```
Възможен изход (16-ичен запис):
```
0x50527c
```

Указателите съществуват за да съхраняват именно тези адреси.

## Деклариране и инициализиране
Декларирането и инициализирането на указателите става по следния начин:
```cpp
<type>* <name>;

<type>* <name> = &<variable>;
```
Например:
```cpp
int a = 10;

int* ptr = &a;
```
Присвояването на числа, различни от 0 е **забранено\***.  
Присвояването на 0 към указател означава, че той сочи към адрес 0, който е запазен, и може да се интерпретира като "не сочи на никъде". В С++ има запазена дума специално за този адрес - `nullptr`.

```cpp
int* ptr = nullptr;
```

Съществува и `NULL`, но той идва от С и е заместител на числото 0. Не се препоръчват и двата варианта 0 и NULL.
```cpp
int a = 0;          // OK
int b = NULL;       // OK, but shouldn't be
int c = nullptr;    // ERROR

int *x = 0;         // OK, but it's bad
int *y = NULL;      // OK, but could be better
int *z = nullptr;   // OK, the way it was meant to be - the C++ way
```

## Синтаксис
Съществуват 3 главни варианта, като изборът е изцяло личен.
```cpp
int* ptr;

int *ptr;

int * ptr;
```

Важно е да се спомене, че това дали една променлива е указател или не, зависи от наличието на * пред името ѝ. Някои програмисти пишат `int *ptr`. Причината за това става по-ясна, когато се опитаме да декларираме няколко указателя на един ред.

```cpp
int* ptr1, ptr2; 
// ptr1 -> указател към тип int
// ptr2 -> просто int
```

```cpp
int *ptr1, *ptr2; // и двете променливи са указатели
```

## Специални операции

Указателите имат някои специални операции. Първата, която ще разгледаме, се нарича дереференция.

### Дереференция
Дереференцията представлява достъпване на стойността зад адреса, към който "сочи" указателя. Това се постига с унарния оператор `*`.

```cpp
int a = 10;

int* ptr = &a;

*ptr = 20;

cout << *ptr << endl << a;
```

```
20
20
```

***Важно!!!*** Никога, ама никога не трябва да дереферирате `nullptr`.  
Това ще доведе то т.нар. `segmentation fault` (`segfault`) - грешка, която известява операционната система че софтуерът се е опитал да достъпи памет, която е защитена. Същата грешка се получава и когато се опитаме да достъпим елементи на масива извън неговите граници.
```cpp
int* p = nullptr;

*p = 123; // SEGFAULT
```


### Указателна аритметика
Когато имаме гаранция, че няколко няколко променливи се намират една след друга в паметта, ни е позволено и да местим указателя напред или назад. Такъв случай са масивите. Ако вземем адреса на някой елемент, можем да се вземем адреса на следващия, като към текущия добавим 1 с ``+ 1``. С други думи можем да се преместим напред с оператор `++` или назад с `--` (или `+=` и `-=`). В случай, че паметта не е последователна, или сме излезли от границите на масива, поведението е *недефинирано*. 

```cpp
int arr[6] {0, 1, 2, 3, 4, 5};

int* ptr = &arr[2]; 

cout << *ptr; // 3

cout << *(ptr + 1); // 4

ptr--;
ptr -= 2;

cout << *ptr; // 0
```

### Разлика на указатели
Отново, ако имаме гарантирана последователност на променливи в паметта (масиви), можем да намерим разликата на 2 указателя, т.е. разстоянието между тях, като просто ги извадим един от друг.

```cpp
int arr[5] {1, 2, 3, 4, 5};

int* ptr1 = &arr[1];
int* ptr2 = &arr[4];

cout << ptr2 - ptr1; // 4
```

Тъй като няма практическа нужда, *събирането* на указатели **не** е възможно.

### Сравняване на указатели
И отново, при последователна памет (масиви), можем да сравним 2 указателя за да видим къде се намират адресите, към които сочат, релативно помежду си.

```cpp
int arr[5] {1, 2, 3, 4, 5};

int* ptr1 = &arr[1];
int* ptr2 = &arr[4];

cout << boolalpha << (ptr2 > ptr1); // true
```

## Указатели и масиви
Оказва се, че разлика между тези 2 неща почти не съществува. Ако се върнем назад и си спомним, че опитът за принтиране на масив по следния начин ``cout << arr;`` даваше странен резултат, се оказва, че има много добра причина за това - идентификаторът на масивът (`arr`) всъщност представлява указател към първия елемент или с други думи - адресът на първия елемент. Това можем да го проверим по следния начин:
```cpp
int arr[] {1,2,3,4};

cout << boolalpha << (arr == &arr[0]);
```
```
true
```
Следователно, операциите, за които говорехме по-рано, се прилагат и тук:
```cpp
cout << *arr;
```
```
1
```
---
```cpp
cout << *(arr + 1);
```
```
2
```
---
Тук можем да забележим и причината, поради която индексирането на масивите започва от 0. Индексирането е просто синтактична захар за следната операция:
```
X[i] := *(X + i)

където:
X е адрес
i е цяло число
```
Тоест `arr[i]` се превръща в `*(arr + i)`.  

Това означава и че можем да напишем ``i[arr]``, защото този израз се превръща в ``*(i + arr)``, което е напълно валидна операция. Но това е просто интересен факт, който няма практическо приложение.

# Псевдоними
Псевдонимите (или референциите) са си указатели, но с доста синтактична захар, за да се избегнат някои ненужни операции.

## Деклариране и инициализиране
Инициализирането на псевдонимите ЗАДЪЛЖИТЕЛНО се случва по време на декларирането по следния начин:
```cpp
<type>& ref = <variable>;
```

Пример:
```cpp
int var = 10;

int& ref = var;
```
Псведонима е именно това - псевдоним за някоя променлива. Всеки път когато кажем `ref`, ще е еквивалентно на това да кажем `var`:

```cpp
ref = 20;
cout << var; // 20

var = 30;
cout << ref; // 30
```

Както виждаме, не е нужно да се занимаваме с адреси, дереференции и прочие. Това ни ограничава от към операции, но когато те не са нужни, можем да си позволим да използваме референции. Псведонимите нямат стойност по подразбиране и не могат да съществуват без зададена стойност. Веднъж зададен псевдоним, стойността му НЕ може да се промени.  

Код, който може да се напише с псевдоним, може и да се напише с указател:

```cpp
// Reference example

int value = 1337;

int& ref = value;

ref = 0;

cout << value; // 0
```

```cpp
// Pointer example

int value = 1337;

int* ptr = &value;

*ptr = 0;

cout << value; // 0
```